---
layout: post
title: Clojure Basics
---

When learning a new language I like to collate the bare minimum amount of syntax and language information in order to start playing around with it by solving [Project Euler](https://projecteuler.net/) Problems. 

This is for my own reference really, but hopefully it could be handy for someone else going along the same path. Its really the absolute minimum that you'd need to start having fun.

# Table of Contents

1.  [Basic Syntax](#org1bce86f)
    1.  [Forms](#org7c8245e)
    2.  [Operations](#orgd6c52cb)
    3.  [Control Flow](#org38be868)
        1.  [if](#orgd459b8a)
        2.  [cond](#org6512bc3)
        3.  [do](#org9d21e09)
        4.  [when](#orgc45d601)
        5.  [and](#org31fd120)
        6.  [or](#org3c5c08b)
    4.  [Data Types](#org70276da)
        1.  [Strings](#org20cba27)
        2.  [Numbers](#orgc76c0c9)
    5.  [Data Structures](#org09211d6)
        1.  [Lists](#org590b5ea)
        2.  [Vectors](#org6b65a73)
        3.  [Maps](#org5f1a2e5)
        4.  [Sets](#org4ab2981)
        5.  [Keywords](#org7802cc1)
    6.  [Core functions](#org7e4e686)
        1.  [def](#org8cf2bf5)
        2.  [cons](#orgfa3623d)
        3.  [conj](#orgfda3218)
        4.  [first](#orgba06402)
        5.  [next](#org54243f7)
        6.  [rest](#orgff9fc9b)
        7.  [nth](#orge547784)
        8.  [take](#org5592050)
        9.  [drop](#org3bec436)
        10. [complement](#orgd6018f1)
2.  [Writing Functions](#orgd4067f8)
    1.  [The Structure of a Function](#orgbb8b92d)
    2.  [Arity](#orgcd7fa65)
        1.  [Using Arity Overloading to provide default arguments](#org4523935)
        2.  [Rest parameter](#org5f245a0)
    3.  [Destructuring](#org97ac8aa)
        1.  [Vectors](#org5e73257)
        2.  [Maps](#orgdd63e43)
    4.  [Anonymous Functions](#orgf2defe7)
    5.  [Threading](#org67b9e4d)
3.  [Tests](#org1d3f084)
    1.  [Writing and running tests](#org27943e9)
    2.  [Asserts](#orgd1c198d)
    3.  [lein-test-refresh](#org0311f61)
    4.  [test.check](#orga15e66c)
4.  [Functional Tools](#orga0902e5)
    1.  [Apply](#org0d95f58)
    2.  [Partial](#org5bf3734)
    3.  [Map](#orge4f9631)
    4.  [Reduce](#org9d2ed10)
    5.  [Filter](#org3578e7f)
    6.  [Comp](#org2cb0072)
    7.  [Memoize](#org9d7afa2)
5.  [Namespaces](#org5a39d73)
    1.  [What are namespaces?](#org03cb1b0)
    2.  [Creating namespaces](#orgc812c56)
    3.  [Alias](#org151e3b0)
6.  [Macros](#org7887dfd)
    1.  [What are Macros?](#org5a0e507)

---

Please note that several of the code examples in this are reworked
examples from one of the following:

-   [ClojureDocs](https://clojuredocs.org)
-   [Clojure for the Brave and True](https://www.braveclojure.com/)
-   [Enterprise Clojure Training by Timothy Pratley](https://github.com/timothypratley/enterprise-clojure-training)

---

<a id="org1bce86f"></a>

# Basic Syntax


<a id="org7c8245e"></a>

## Forms

Forms are the basis of Clojure's syntax. 
These include:

-   operations

-   literal representations of data, such as:
    -   strings
    -   numbers

-   data structures, such as:
    -   lists
    -   vectors
    -   maps


<a id="orgd6c52cb"></a>

## Operations

In Clojure operations all take the form of:
open-parenthesis, operator, operands, close-parenthesis

```clojure
    (operator operand-a operand-b)
```

<a id="org38be868"></a>

## Control Flow


<a id="orgd459b8a"></a>

### if

Clojure has conditionals to control flow, such as **if**,
which has the following structure:

```clojure
    (if operation-that-returns-Boolean
      then-do-this
      else-do-this)
```

Notice that the operator **if** takes takes three operands here.
The first is resolves to a Boolean. If this is truthy then the first
of the two possible branches will be evaluated (in this case **then-do-this**).
Otherwise, the other branch, **else-do-this** will be evaluated.

Having the other branch is optional, much like an **else** term in Ruby or Python.
If no alternate branch is provided, when the conditional is evaluated as false, Clojure will return **nil**.

1.  Truthy and Falsey expressions:

- Falsey: **false** , **nil**
- Truthy: **true** , everything else

Notably, the number 0 is a truthy expression in Clojure.


<a id="org6512bc3"></a>

### cond

The **cond** function is for a switch-like control flow.
Each condition is stated, followed by the result of that condition.


```clojure
    (defn pos-neg-or-zero
      "Determines whether or not n is positive, negative, or zero"
      [n]
      (cond
        (< n 0) "negative"
        (> n 0) "positive"
        :else "zero"))
    
    (pos-neg-or-zero 5)
    
    ;=> "positive"
    
    (pos-neg-or-zero -1)
    
    ;=> "negative"
    
    (pos-neg-or-zero 0)
    
    ;=> "zero"
```

<a id="org9d21e09"></a>

### do

The **do** operator allows you to evaluate multiple expressions in order.

```clojure
    (do (+ println "hello")
        (+ println "hello again!"))
    
    ;=> hello
    ;=> hello again!
    ;=> nil

Here we have used **println** to print a string as a line.
the **;=>** symbols represent the output of evaluating this **do** expression.
Here each of the sub-expressions have been executed. 
Finally, the return value of the last sub-expression is returned.
(**println** expressions return **nil**)


<a id="orgc45d601"></a>

### when

the **when** operator works like a **if** operator, 
but with no optional second branch. Therefore **when** always returns nil when the Boolean is falsey.
**when** also allows you to evaluate multiple expressions, like **do**.


```clojure
    (when true
      (println "multiple")
      (println "expressions"))
    
    ;=> multiple
    ;=> expressions
    ;=> nil

```

<a id="org31fd120"></a>

### and

The **and** operator returns the first falsey value, or if there are no falsey values, 
the last truthy one. 

```clojure
    (and false true)
    ;=> false
    
    (and (= "a" "a") true 1 0 "last one")
    ;=> "last one"
    
    (and 0 "my string" nil true)
    ;=> nil

```

<a id="org3c5c08b"></a>

### or

The **or** operator returns the first truthy value, or if there are no truthy values,
the last value

```clojure
    (or false true)
    ;=> true
    
    (or 1 0 "last one")
    ;=> 1
    
    (or 0 "my string" nil true)
    ;=> 0

```

<a id="org70276da"></a>

## Data Types


<a id="org20cba27"></a>

### Strings

Strings are surrounded in double quotes. 
A backslash can be used to escape special characters.

```clojure
    (println "let's print some double quotes: \"\"\"")
    
    ;=> let's print some double quotes: """
    ;=> nil

```
The function **str** can be used to make a single string out of multiple string.

```clojure
    (def first_part "This is the beginning, ")
    (println (str (first_part "and this is the end.")))
    
    ;=> This is the beginning, and this is the end.
    ;=> nil

```

<a id="orgc76c0c9"></a>

### Numbers

Clojure handles integers, floating point numbers and ratios nativity.

```clojure
    (+ 1.5 2)
    
    ;=> 3.5
    
    (* 1/2 1/3)
    
    ;=> 1/6

```

<a id="org09211d6"></a>

## Data Structures


<a id="org590b5ea"></a>

### Lists

Lists are collections of values.
Lists in Clojure use parentheses, and so look a lot like functions.
In order to signify that we are using a list rather than a function to be evaluated,
we put a single quote in-front of the list.

```clojure
    '(1 2 3 4)
    
    ;=> (1 2 3 4)

Note that there is no need for commas between items of a list. Functions such as **first**, **last** and **nth** can be used on lists.

```clojure
    (first '(1 2 3 4))
    
    ;=> 1
    
    (last '(1 2 3 4))
    
    ;=> 4
    
    (nth '(1 2 3 4) 2)
    
    ;=> 3

```
Note that **nth**'s second argument is the value of n, which is 0-indexed.


<a id="org6b65a73"></a>

### Vectors

Vectors are like lists in some ways, however they have some different properties. 
They do not require a single quote in-front of of them. They use square braces. 
Rather than using **nth**, items can be pulled from a vector using **get**.

```clojure
    (get [1 2 3 4] 0)
    
    ;=> 1

```
Vector elements can be of any type. As with lists.


<a id="org5f1a2e5"></a>

### Maps

Maps are analogous to hashes in Ruby, or dictionaries in Python. 
They are contained in curly braces and key, value pairs are simply added in that order.

```clojure
    (def my-map {:first-key "the first one" :second-key "another one"})
    (println (my-map :second-key))
    
```clojure
    ;=> another one

```
Map values can be of any type. Strings, numbers, nested maps, functions.
Anything. 


<a id="org4ab2981"></a>

### Sets

Sets are collections of unique values. They can ether be hash-sets or sorted sets.
Hash-sets are formatted like so:

```clojure
    #{:a :b "another item" 12}
    
    ;=> #{"another item" 12 :b :a}

```
Note how it doesn't retain it's order. 

Calling **hash-set** on a number of data objects will return a hash-set of them, excluding duplicates.

```clojure
    (hash-set 1 5 2 5 7)
    
    ;=> #{7 1 2 5}

```

<a id="org7802cc1"></a>

### Keywords

Keywords are mainly used as keys in maps. They always evaluate to themselves. 

```clojure
    :test-keyword
    
    ;=> :test-keyword
    
    (do 
        (def my-map {:a 1 :b 2})
        (:a my-map))
    
    ;=> 1


```
<a id="org7e4e686"></a>

## Core functions


<a id="org8cf2bf5"></a>

### def

the **def** operator binds a name to a value in Clojure. 
Generally it is preferable to not re-assign a new value to a name in Clojure.

```clojure
    (def super-example "this is my great example")
    
    (println super-example)
    
    ;=> this is my great example

```

<a id="orgfa3623d"></a>

### cons

Prepends an item to a list.

```clojure
    (cons 1 '(2 3 4 5 6))
    
    ;=> (1 2 3 4 5 6)


```
<a id="orgfda3218"></a>

### conj

Adds an item to a collection. 
If it's a vector, the new item will be added at the end.
If it's a list it'll be added at the beginning.

```clojure
    (conj [1 2 3] 4)
    
    ;=> [1 2 3 4]
    
    (conj '(1 2 3) 4)
    
    ;=> (4 1 2 3)

```

<a id="orgba06402"></a>

### first

Returns the first item in a sequence.

```clojure
    (first '(:alpha :bravo :charlie))
    
    ;=> :alpha


```
<a id="org54243f7"></a>

### next

Returns all apart from the first item in a sequence.
If the sequence contains only one item **next** will return **nil**.

```clojure
    user=> (next '(:alpha :bravo :charlie))
    
    ;=> (:bravo :charlie)
    
    user=> (next (next '(:one :two :three)))
    
    ;=> (:three)
    
    user=> (next (next (next '(:one :two :three))))
    
    ;=> nil

```

<a id="orgff9fc9b"></a>

### rest

Like **next** but always returns a sequence.

```clojure
    (rest [1 2 3 4 5])           
    
    ;=> (2 3 4 5)
    
    (rest '())
    
    ;=> ()

```

<a id="orge547784"></a>

### nth

Returns value at index n.

```clojure
    (def my-seq ["a" "b" "c" "d"])
    
    (nth my-seq 0)
    
    ;=> "a"
    
    (nth my-seq 1)
    
    ;=> "b"
    
    (nth [] 0)
    
    ;=> IndexOutOfBoundsException ...
    
    (nth [] 0 "nothing found")
    
    ;=> "nothing found"
    
    (nth [0 1 2] 77 1337)
    
    ;=> 1337

```

<a id="org5592050"></a>

### take

Takes the first n items from a sequence.

```clojure
    ;; return a lazy seq of the first 3 items
    (take 3 '(1 2 3 4 5 6))
    
    ;=> (1 2 3)

```

<a id="org3bec436"></a>

### drop

Discards the first n items from a sequence.
Returns a list 

```clojure
    (drop 2 [1 2 3 4])
    
    ;=> (3 4) 

```

<a id="orgd6018f1"></a>

### complement

Complement simply inverts the return value of a function that returns a Boolean.

```clojure
    (defn my-even-test
      [x]
      (even? x))
    
    (def my-odd-test (complement my-even-test))
    
    (my-odd-test 1)
    
    ;=> true

```

<a id="orgd4067f8"></a>

# Writing Functions


<a id="orgbb8b92d"></a>

## The Structure of a Function

A main parts of a function are the following:

-   **defn**
-   The function's name.
-   A description of the function (aka a docstring).
-   The parameters listed in square brackets.
-   The body of the function.

```clojure
    (defn my-new-addition-function
      "This is a function that takes two numbers and sums them."
      [first-number second-number]
      (+ first-number second-number))
    
    (my-new-addition-function 3 5)
    ;=> 8
```

Functions can contain any number of forms.
All the forms will be evaluated, unless there are conditionals inside the function.
The evaluation of the last form will be the return value of the function.

```clojure
    (defn many-forms-one-return
      []
      (+ 1 1)
      (+ 1 2)
      (/ 1 2)
      (- 9 3))
    
    (many-forms-one-return)
    
    ;=> 6

```

<a id="orgcd7fa65"></a>

## Arity

A function's arity is the number of parameters it takes. 
Clojure functions support *arity overloading*, 
which is polymorphism controlled by the arity of the function.  

Airty overloading is added to a function by 
providing each arity definition in parentheses. 
Each definition includes an argument list, 
followed by a function body.

```clojure
    (defn my-multi-arity-function
      ([one two three]
       (println "Three arguments!"))
    
      ([one two]
       (println "Two arguments!"))
    
      ([one]
       (println "One argument!")))
    
    (my-multi-arity-function 666 "frogs")
    
    ;=> Two arguments!

```

<a id="org4523935"></a>

### Using Arity Overloading to provide default arguments

Since a function can call itself recursively, arity overloading can be used to provide default arguments. 

```clojure
    (defn func-with-default-arg
        ([number-to-print]
    	(println (str "here a number for you: " number-to-print)))
        ([]
    	(func-with-default-arg 99)))
    
    (func-with-default-arg 100)
    
    ;=> 100 
    
    (func-with-default-arg)
    
    ;=> 99

```

<a id="org5f245a0"></a>

### Rest parameter

A function can take an unspecified number of arguments. 
Kind of like **argv** in a c-style language.
Clojure uses an ampersand **&** followed by a name to signify a rest parameter in the argument list.
Named individual arguments can be put before the rest.

```clojure
    (defn func-using-rest
        [named-arg-a named-arg-b & other-args]
        (println (str "A is : " named-arg-a " and B is : " named-arg-b 
    		  " and the rest sum to: " (reduce + other-args))))
    
    (func-using-rest 10 20 1 2 3 4 5)
    
    ;=> A is : 10 and B is : 20 and the rest sum to: 15

```

<a id="org97ac8aa"></a>

## Destructuring


<a id="org5e73257"></a>

### Vectors

The same rest principle can be applied to vectors passed as arguments. 
We can simply name consecutive items in the vector, followed by a rest parameter.

```clojure
    (defn destruct-vec
      [[first second & rest] another-arg arg-three]
      (println (str "the second item in the vector is " second
    		" and you also passed " another-arg " and "
    		arg-three)))
    
    (destruct-vec [99 "frog" :keyname] "floop" "gloop")
    
    ;=> the second item in the vector is frog and you also passed floop and gloop

```

<a id="orgdd63e43"></a>

### Maps

There are several methods for destructuring maps. 
We can name the keys, like so:

```clojure
    (defn destruct-map-1
      [{first-key :a second-key :b}]
      (+ first-key second-key))
    
    (destruct-map-1 {:a 10 :b 20})
    
    ;=> 30

```
We can also detructure the keys using the **:keys** keyword. 

```clojure
    (defn destruct-map-2
      [{:keys [first-key second-key]}]
      (+ first-key second-key))
    
    (destruct-map-1 {:a 1/2 :b 1/4})
    
    ;=> 3/4

```

<a id="orgf2defe7"></a>

## Anonymous Functions

Anonymous functions, sometimes known as *lambda expressions* 
or simply *lambdas*, are available in Clojure. 
Here are a couple of syntaxes for *lambdas*:

```clojure
    ((fn [a b]
       (* a b)) 9 100)
    
    ;=> 900
    
    (#(* % 3) 2)
    
    ;=> 6

```
Using the hash syntax we can also give rest parameters.
He we have done so, also using the **reduce** function to 
sequentially apply the addition.

```clojure
    (#(reduce + %&) 1 2 3 4 5)
    
    ;=> 15 

```
The above is a contrived example to show the lambda 
using a rest parameter.
We will revisit **reduce** below.


<a id="org67b9e4d"></a>

## Threading

Nesting operations within operations can become difficult to read.
The threading syntax can make things clearer.

Thread first and thread last are two different syntaxes to represent this.
Thread first uses a **->**,
Whereas thread last uses a **->>**.

```clojure
    (defn not-threaded
      [a]
      (even? (* 7 (inc a))))
    
    
    (defn thread-first
      [a]
      (->
        (inc a)
        (* 7)
        (even?)))
    
    
    (defn thread-last
      [a]
      (->>
        (even?)
        (* 7)
        (inc a)))


```
<a id="org1d3f084"></a>

# Tests


<a id="org27943e9"></a>

## Writing and running tests

Tests are usually put in test directory, 
at the same level as the src directory in a Clojure project.

Naming convention is to have the same name as the src file,
appended with *\_test*.

```clojure
    my_project/test/my_code.clj
    
    my_project/src/my_code_test.clj

```
Tests are simply functions that take no arguments.
They are declared like so:

```clojure
    (deftest my-test
      (println "Here is a test!"))

```
Tests can be run from the REPL:

```clojure
    (run-tests)

```
Also, all a project's tests can be run from a shell.

```shell
    $ lein test

```

<a id="orgd1c198d"></a>

## Asserts

An assert in a test can be written with an **is**. 
Additional structure can be added with a **testing** block. 
Details of the test can be added with an optional string argument to the **is**.

```clojure
    (defn my-test
      (testing "let's begin our tests!"
        (is (= 1 2) "tests if one is equal to two")))
    
    ;=> FAIL in (my-test)
    ;=> let's begin our tests!
    ;=> tests if one is equal to two
    ;=> expected: (= 1 2))
    ;=> actual: (not (= 1 2))

```

<a id="org0311f61"></a>

## lein-test-refresh

This is a Leiningen plugin that live-refreshes tests after you save a file.

To install add this to your plugins in `~/.lein/profiles.clj`

```clojure
    [com.jakemccrary/lein-test-refresh "0.23.0"]

```
To run it in the shell:

```shell
    $ lein test-refresh
```

<a id="orga15e66c"></a>

## test.check


<a id="orga0902e5"></a>

# Functional Tools


<a id="org0d95f58"></a>

## Apply

The **apply** function allows us to treat the items in a sequence as arguments to a function.
For example.

```clojure
    (max 2 4 6 8 10)
    
    ;=> 10
    
    (apply max [2 4 6 8 10])
    
    ;=> 10

```

<a id="org5bf3734"></a>

## Partial

The **partial** function can be used to make higher order functions. 

```clojure
    (def splitter (partial * 0.5))
    
    (splitter 3)
    
    ;=> 1.5

```

<a id="orge4f9631"></a>

## Map

Applies a function to each item in a sequence. 
If more than one sequence is passed then each corresponding value by index 
is passed as an argument simultaneously.
Returns a lazy sequence.

```clojure
    (map inc [1 2 3 4 5])
    
    ;=> (2 3 4 5 6)
    
    (map + [1 2 3] [4 5 6])
    
    ;=> (5 7 9)

```

<a id="org9d2ed10"></a>

## Reduce

Applies a two argument function across a sequence.
Takes the outcome of the previous function all and the next consecutive item in the sequence.
This is done repeatedly until the sequence is empty.

```clojure
    (reduce + [1 2 3 4 5]) 
    
    ;=> 15
    
    (reduce + [])          
    
    ;=> 0
    
    (reduce + 1 [2 3])     
    
    ;=> 6

```

<a id="org3578e7f"></a>

## Filter

Filters a sequence by a predicate. 

```clojure
    (filter even? (range 10))
    
    ;=> (0 2 4 6 8)
    
    
    (filter #(= (count %) 1)
      ["a" "aa" "b" "n" "f" "lisp" "clojure" "q" ""])
    
    ;=> ("a" "b" "n" "f" "q")

```

<a id="org2cb0072"></a>

## Comp

This is used to compose functions from multiple other functions.

```clojure
    ((comp inc *) 2 3)
    
    ;=> 7

```
In a quasi-mathematical notation, we can compose functions&#x2026;

$$f_{1}, f_{2}, ... ,f_{n}$$

&#x2026; to create a new function, **g**, such that:

$$g(x_{1},  x_{2}, ... x_{n}) = f_{1}(f_{2} (...( f_{n}(x_{1}, x_{2} ...  x_{n}))...))$$

Note the above will not be rendered correctly in GitHub flavour markdown.


<a id="org9d7afa2"></a>

## Memoize

This will save the outcome of a function call provided with specified arguments.

```clojure
    user=> (defn myfunc[a] (println "doing some work") (+ a 10))
    
    user=> (def myfunc-memo (memoize myfunc))
    
    user=> (myfunc-memo 1)
    
    ;=> doing some work
    ;=> 11
    
    user=> (myfunc-memo 1)
    
    ;=> 11
    
    user=> (myfunc-memo 20)
    
    ;=> doing some work
    ;=> 30
    
    user=> (myfunc-memo 20)
    
    ;=> 30


```
<a id="org5a39d73"></a>

# Namespaces


<a id="org03cb1b0"></a>

## What are namespaces?

Namespaces in Clojure are simmilar to namespaces in C++.
They can contain mappings between symbols and values.
The current namespace can be refered to like so:

```clojure
    *ns*

```
We can see a namespace's name with the **ns-name** function.
If we were to use this in the REPL,
by default we'd get the following response.

```clojure
    (ns-name *ns*)
    
    ;=> user

```
When an object is stored with **def**, 
this is added to the current namespace. 

Again, we can see this in the REPL:

```clojure
    (def my-obj {:a "value 1" :b "value 2"})
    
    ;=> user/my-obj

```
We can all of a namespace's mappings of symbols using **ns-interns**

```clojure
    (ns-interns *ns*)
    
    ;=> my-obj #'user/my-obj


```
<a id="orgc812c56"></a>

## Creating namespaces

A namespace can be made with **create-ns**.

```clojure
    (create-ns my-new-namespace)

```
However, it can be more convenient to switch to a new namespace
once it's made.
This can be done in a single command, like so:

```clojure
    (in-ns my-super-namespace)

```
If the namespace name already exists, 
the above will simply cause you to move into the given namespace.


<a id="org151e3b0"></a>

## Alias

The **alias** function can be used to give an abbreviated version of
a namespace in order to refer to fully qualified symbols more easly.

Suppose we are in the **my-super-namespace** created above, 
and we want to refer to the object we previously made in the **user**
namespace using an alias:

```clojure
    (clojure.core/alias 'u 'user)
    
    u/my-obj
    
    ;=> {:a "value 1" b: "value 2"}


```

<a id="org7887dfd"></a>

# Macros


<a id="org5a0e507"></a>

## What are Macros?

Macros allow the compiler to be extended with user code. 
Several of Clojure's core constructs which would be primatives in other languages are in fact macros in Clojure.
For example **when** is a macro. We can see this by using **macroexpand**.

```clojure
    (macroexpand '(when (pos? a) (println "positive") (/ b a)))
    
    ;=> (if (pos? a) (do (println "positive") (/ a b)))

```
Here we can see that **when** is in fact a macro that uses **if** and **do**.

Macros are like functions, but they take arguments without evaluating them.
Here is a superflous 'macro', which is really just behaving like a function.

```clojure
    (defmacro plus-func
      [a b]
      (+ a b))
    
    (plus-func 1 2)
    
    ;=> 3

```
It serves no perpose for this function to be declared with **defmacro**. 
It should be just a regular function.

Since macros allow us to take arguments without evaluating them, 
we can use them to alter the expected behaviour of lists.

```clojure
    (defmacro infix
    ; Here destructuring is used to name the items in the passed list.
      [[first-arg second-arg third-arg]]
      (second-arg first-arg third-arg))
    
    ; Now we can perform simple additions with infix, rather than prefix notation.
    (infix (1 + 2))
    
    ;=> 3	
```
